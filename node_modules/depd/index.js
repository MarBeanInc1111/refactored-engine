/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

const util = require('util');
const callSiteToString = require('./lib/compat').callSiteToString;
const eventListenerCount = require('./lib/compat').eventListenerCount;
const relative = require('path').relative;
const { callSiteLocation, getStack } = require('./lib/utils');

const basePath = process.cwd();

function containsNamespace(str, namespace) {
  const vals = str.split(/[ ,]+/);
  const ns = String(namespace).toLowerCase();

  for (let i = 0; i < vals.length; i++) {
    const val = vals[i];

    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true;
    }
  }

  return false;
}

function convertDataDescriptorToAccessor(obj, prop, message) {
  const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  const value = descriptor.value;

  descriptor.get = function getter() { return value };

  if (descriptor.writable) {
    descriptor.set = function setter(val) { return (value = val) };
  }

  delete descriptor.value;
  delete descriptor.writable;

  Object.defineProperty(obj, prop, descriptor);

  return descriptor;
}

function createArgumentsString(arity) {
  let str = '';

  for (let i = 0; i < arity; i++) {
    str += ', arg' + i;
  }

  return str.substr(2);
}

function createStackString(stack) {
  let str = this.name + ': ' + this.namespace;

  if (this.message) {
    str += ' deprecated ' + this.message;
  }

  const newline = require('os').EOL;

  for (let i = 0; i < stack.length; i++) {
    str += '\n    at ' + callSiteToString(stack[i]);
  }

  return str;
}

function depd(namespace) {
  if (typeof namespace !== 'string') {
    throw new TypeError('argument namespace is required');
  }

  if (namespace.includes('.')) {
    throw new Error('namespaces cannot contain periods');
  }

  const stack = getStack();
  const site = callSiteLocation(stack[1]);
  const file = site[0];

  function warn(message) {
    // call to self as log
    log.call(this, message);
  }

  warn._file = file;
  warn._ignored = isignored(namespace);
  warn._namespace = namespace;
  warn._traced = istraced(namespace);
  warn._warned = Object.create(null);

  warn.function = wrapfunction;
  warn.property = wrapproperty;

  return warn;
}

function isignored(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.noDeprecation) {
    // --no-deprecation support
    return true;
  }

  const str = process.env.NO_DEPRECATION || '';

  // namespace ignored
  return containsNamespace(str, namespace);
}

function istraced(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true;
  }

  const str = process.env.TRACE_DEPRECATION || '';

  // namespace traced
  return containsNamespace(str, namespace);
}

function log(message, site) {
  const haslisteners = eventListenerCount(process, 'deprecation') !== 0;

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return;
  }

  let caller;
  let callFile;
  let callSite;
  let depSite;
  let i = 0;
  let seen = false;

  if (site) {
    // provided site
    depSite = site;
    callSite = callSiteLocation(stack[i]);
    callFile = callSite[0];
  } else {
    // use first site from stack
    depSite = callSiteLocation(stack[i = 1]);
    callFile = depSite[0];
  }

  // find first site not in our file
  while (callFile === file && i < stack.length) {
    if (++i
