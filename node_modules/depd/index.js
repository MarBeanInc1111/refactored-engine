/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

const callSiteToString = require('./lib/compat').callSiteToString
const eventListenerCount = require('./lib/compat').eventListenerCount
const relative = require('path').relative

/**
 * Module exports.
 */

module.exports = depd

/**
 * Get the path to base files on.
 */

const basePath = process.cwd()

/**
 * Determine if namespace is contained in the string.
 * @param {string} str - The string to check.
 * @param {string} namespace - The namespace to search for.
 * @returns {boolean} True if the namespace is found, false otherwise.
 */

function containsNamespace(str, namespace) {
  const vals = str.split(/[ ,]+/)
  const ns = String(namespace).toLowerCase()

  for (let i = 0; i < vals.length; i++) {
    const val = vals[i]

    // namespace contained
    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true
    }
  }

  return false
}

/**
 * Convert a data descriptor to accessor descriptor.
 * @param {object} obj - The object to modify.
 * @param {string} prop - The property to modify.
 * @param {string} message - The deprecation message.
 */

function convertDataDescriptorToAccessor(obj, prop, message) {
  const descriptor = Object.getOwnPropertyDescriptor(obj, prop)
  const value = descriptor.value

  descriptor.get = function getter() { return value }

  if (descriptor.writable) {
    descriptor.set = function setter(val) { return (value = val) }
  }

  delete descriptor.value
  delete descriptor.writable

  Object.defineProperty(obj, prop, descriptor)

  return descriptor
}

/**
 * Create arguments string to keep arity.
 * @param {number} arity - The number of arguments.
 * @returns {string} The arguments string.
 */

function createArgumentsString(arity) {
  let str = ''

  for (let i = 0; i < arity; i++) {
    str += ', arg' + i
  }

  return str.substr(2)
}

/**
 * Create stack string from stack.
 * @param {Array<Object>} stack - The stack to convert.
 * @returns {string} The stack string.
 */

function createStackString(stack) {
  let str = this.name + ': ' + this.namespace

  if (this.message) {
    str += ' deprecated ' + this.message
  }

  for (let i = 0; i < stack.length; i++) {
    str += '\n    at ' + callSiteToString(stack[i])
  }

  return str
}

/**
 * Create deprecate for namespace in caller.
 * @param {string} namespace - The namespace to deprecate.
 * @returns {Function} The deprecate function.
 */

function depd(namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required')
  }

  const stack = getStack()
  const site = callSiteLocation(stack[1])
  const file = site[0]

  function deprecate(message) {
    // call to self as log
    log.call(deprecate, message)
  }

  deprecate._file = file
  deprecate._ignored = isignored(namespace)
  deprecate._namespace = namespace
  deprecate._traced = istraced(namespace)
  deprecate._warned = Object.create(null)

  deprecate.function = wrapfunction
  deprecate.property = wrapproperty

  return deprecate
}

/**
 * Determine if namespace is ignored.
 * @param {string} namespace - The namespace to check.
 * @returns {boolean} True if the namespace is ignored, false otherwise.
 */

function isignored(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.noDeprecation) {
    // --no-deprecation support
    return true
  }

  const str = process.env.NO_DEPRECATION || ''

  // namespace ignored
  return containsNamespace(str, namespace)
}

/**
 * Determine if namespace is traced.
 * @param {string} namespace - The namespace to check.
 * @returns {boolean} True if the namespace is traced, false otherwise.
 */

function istraced(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true
  }

  const str = process.env.TRACE_DEPRECATION || ''

  // namespace traced
  return containsNamespace(str, namespace)
}

/**
 * Display deprecation message.
 * @param {string} message - The deprecation message.
 * @param {Object} site - The call site object.
 */

function log(message, site) {
  const haslisteners = eventListenerCount(process, 'deprecation') !== 0

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return
  }

  let caller
  let callFile
  let callSite
  let depSite
  let i = 0
  let seen = false
  const stack = getStack()
  const file = this._file

  if (site) {
    // provided site
    depSite = site
    callSite = callSiteLocation(stack[1])
    call
