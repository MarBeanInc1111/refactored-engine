/*!
 * csurf
 * MIT Licensed
 *
 * A CSRF protection middleware for Node.js and Express.
 * This module signs a token which should be added to requests which mutate
 * state, within a hidden form field, query-string etc. This token is validated
 * against the visitor's session.
 */

'use strict'

const Cookie = require('cookie')
const createError = require('http-errors')
const sign = require('cookie-signature').sign
const Tokens = require('csrf')

// Default value function, checking the `req.body`
// and `req.query` for the CSRF token.
function defaultValue (req) {
  return (req.body && req.body._csrf) ||
    (req.query && req.query._csrf) ||
    (req.headers['csrf-token']) ||
    (req.headers['xsrf-token']) ||
    (req.headers['x-csrf-token']) ||
    (req.headers['x-xsrf-token'])
}

// Get options for cookie.
function getCookieOptions (options) {
  if (options !== true && typeof options !== 'object') {
    return undefined
  }

  const opts = Object.create(null)

  // defaults
  opts.key = '_csrf'
  opts.path = '/'

  if (options && typeof options === 'object') {
    for (const prop in options) {
      const val = options[prop]

      if (val !== undefined) {
        opts[prop] = val
      }
    }
  }

  return opts
}

// Get a lookup of ignored methods.
function getIgnoredMethods (methods) {
  const obj = Object.create(null)

  for (let i = 0; i < methods.length; i++) {
    const method = methods[i].toUpperCase()
    obj[method] = true
  }

  return obj
}

// Get the token secret from the request.
function getSecret (req, sessionKey, cookie) {
  // get the bag & key
  const bag = getSecretBag(req, sessionKey, cookie)
  const key = cookie ? cookie.key : 'csrfSecret'

  if (!bag) {
    throw new Error('misconfigured csrf')
  }

  // return secret from bag
  return bag[key]
}

// Get the token secret bag from the request.
function getSecretBag (req, sessionKey, cookie) {
  if (cookie) {
    // get secret from cookie
    const cookieKey = cookie.signed
      ? 'signedCookies'
      : 'cookies'

    return req[cookieKey]
  } else {
    // get secret from session
    return req[sessionKey]
  }
}

// Set a cookie on the HTTP response.
function setCookie (res, name, val, options) {
  const data = Cookie.serialize(name, val, options)

  const prev = res.getHeader('set-cookie') || []
  const header = Array.isArray(prev) ? prev.concat(data)
    : [prev, data]

  res.setHeader('set-cookie', header)
}

// Set the token secret on the request.
function setSecret (req, res, sessionKey, val, cookie) {
  if (cookie) {
    // set secret on cookie
    let value = val

    if (cookie.signed) {
      value = 's:' + sign(val, req.secret)
    }

    setCookie(res, cookie.key, value, cookie)
  } else {
    // set secret on session
    req[sessionKey].csrfSecret = val
  }
}

// Verify the configuration against the request.
function verifyConfiguration (req, sessionKey, cookie) {
  if (!getSecretBag(req, sessionKey, cookie)) {
    return false
  }

  if (cookie && cookie.signed && !req.secret) {
    return false
  }

  return true
}

// Module exports.
const csurf = (options) => {
  if (!Cookie) {
    throw new Error('Cookie dependency is missing')
  }

  if (!createError) {
    throw new Error('CreateError dependency is missing')
  }

  if (!sign) {
    throw new Error('Sign dependency is missing')
  }

  if (!Tokens) {
    throw new Error('Tokens dependency is missing')
  }

  const opts = options || {}

  // get cookie options
  const cookie = getCookieOptions(opts.cookie)

  // get session options
  const sessionKey = opts.sessionKey || 'session'

  // get value getter
  const value = opts.value || defaultValue

  // token repo
  const tokens = new Tokens(opts)

  // ignored methods
  const ignoreMethods = opts.ignoreMethods === undefined
    ? ['GET', 'HEAD', 'OPTIONS']
    : opts.ignoreMethods

  if (!Array.isArray(ignoreMethods)) {
    throw new TypeError('option ignoreMethods must be an array')
  }

  // generate lookup
  const ignoreMethod = getIgnoredMethods(ignoreMethods)

  return (req, res, next) => {
    // validate the configuration against request
    if (!verifyConfiguration(req, sessionKey, cookie)) {
      return next(new Error('misconfigured csrf'))
    }

    // get the secret from the request
    let secret = getSecret(req, sessionKey, cookie)
    let token

    // lazy-load token getter
    req.csrfToken = () => {
      let sec = !cookie
        ? getSecret(req, sessionKey, cookie)
        : secret

      // use cached token if secret has not changed
      if (token && sec === secret) {
        return token
      }

      // generate & set new
